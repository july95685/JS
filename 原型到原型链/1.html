<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
  </head>
  <script>
  	function Person(){

  	}
  	//prototype是函数才会有的属性
  	Person.prototype.name = 'Kevin';
  	var person = new Person();

  	// 那么问题来了，这个函数的prototype到底指向什么？__proto__?
  	// 函数的prototype属性指向一个对象，这个对象正是调用该构造函数而
  	// 创建的实例的原型，也就是person的原型
  	// 那什么是原型呢？
  	// 可以这么理解，每一个jacascript对象(null除外)在创建的时候就会关联
  	// 另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性
  	// 那么我们怎么表示实例与实例原型之间的关系呢，也是就person与Person.prototype之间的关系
  	// 这时候我们就有了第二个属性_proto_
  	// 这是除了null每个javascript都有的属性，这个属性会指向该对象的原型
  	// 即 Person.prototype === person.__proto__
  	//  既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向实例呢
  	//  于是就有了constructor  = =但是并不行
  	//  指向实例倒是没有，因为一个构造函数可以生出很多个实例，但是原型指向构造函数
  	//  还是有的，这才是constructor，每一个原型有一个constructor指向相关联的构造函数
  	//  即 Person === Person.prototype.constructor
  	//  顺便学习一个ES5的方法用来获取对象的原型
  	//  console.log(Object.getPrototypeOf(person) === Person.prototype)
  	//  
  	//  实例与原型
  	//  当读取实例的属性读取不到时，就会去查找与对象关联的原型的属性，如果还是
  	//  查找不到，就继续向上查找至最高层
  	//  举个例子
  	function Person(){}
  	Person.prototype.name = 'a';
  	var person = new Person();
  	person.name = 'b';
  	console.log(person.name);
  	delete person.name;
  	console.log(person.name);
  	//原型的原型又是什么呢
  	//我们已经说过了，原型也是一个对象，我们就可以用最原始的方法创建他
  	var obj = new Object();
  	obj.name = 'kevin';
  	console.log(obj.name);
  	//所以原型对象是通过Object构造函数生成的
  	//即Person.prototype.__proto__ === Object.prototype 
  	//
  	//原型链
  	//Object prototype是的原型呢？
  	//null,我们可以打印console.log(Object.prototype.__proto__ === null) //true
  	//null表示没有对象，即该处不应该有值
  	//所以Object.prototype.__proto__的值为null即说Object.prototype没有原型
  	//
  	//补充关于constructor
  	//当我们去获取person.constructor时，我们会得到Person
  	//即person中没有constructor属性，当不能读到constructor属性时，会从person的原型
  	//即Person.prototype查找constructor
  	//Person.prototype.constructor
  </script>
  <body>

  </body>
</html>